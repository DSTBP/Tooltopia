<!doctype html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Lights Out - 立方体版</title>
    <link rel="icon" href="favicon.png">
    <link rel="stylesheet" href="assets/css/style.css">
    
    <script src="assets/js/theme-init.js"></script>
    <style>
        .cube-container {
            perspective: 1000px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 500px;
            margin: 20px 0;
        }
        
        .cube {
            position: relative;
            width: 300px;
            height: 300px;
            transform-style: preserve-3d;
            cursor: grab;
            user-select: none;
        }
        
        .cube:active {
            cursor: grabbing;
        }
        
        .cube-hint {
            color: #666;
            font-size: 0.9rem;
            margin-left: 10px;
        }
        
        .cube-face {
            position: absolute;
            width: 300px;
            height: 300px;
            border: 2px solid #333;
            background: rgba(255, 255, 255, 0.9);
            display: grid;
            gap: 2px;
            padding: 5px;
        }
        
        .cube-face.front { transform: rotateY(0deg) translateZ(150px); }
        .cube-face.back { transform: rotateY(180deg) translateZ(150px); }
        .cube-face.right { transform: rotateY(90deg) translateZ(150px); }
        .cube-face.left { transform: rotateY(-90deg) translateZ(150px); }
        .cube-face.top { transform: rotateX(90deg) translateZ(150px); }
        .cube-face.bottom { transform: rotateX(-90deg) translateZ(150px); }
        
        .cube-cell {
            background: #f0f0f0;
            border: 1px solid #ccc;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        
        .cube-cell.on {
            background: #ffeb3b;
            box-shadow: 0 0 10px rgba(255, 235, 59, 0.5);
        }
        
        .cube-cell.hint-highlight {
            background: #ff9800;
            color: white;
            font-weight: bold;
        }
        
        .face-label {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-weight: bold;
            color: #333;
        }
        
        /* 语言选择器统一样式 - 使用更强的选择器 */
        #translate,
        #translate .translate_selectLanguage_tag,
        .translate_selectLanguage_tag,
        div[id="translate"],
        div[id="translate"] .translate_selectLanguage_tag {
            position: fixed !important;
            top: 20px !important;
            right: 20px !important;
            z-index: 9999 !important;
            background: rgba(255, 255, 255, 0.15) !important;
            color: white !important;
            padding: 0 !important;
            border-radius: 20px !important;
            border: 1px solid rgba(255, 255, 255, 0.3) !important;
            backdrop-filter: blur(10px) !important;
            cursor: pointer !important;
            font-size: 0.9rem !important;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
            transition: all 0.3s ease !important;
            display: inline-block !important;
            margin: 0 !important;
            min-width: 120px !important;
            height: 36px !important;
            overflow: visible !important;
        }
        
        #translate:hover,
        #translate .translate_selectLanguage_tag:hover,
        .translate_selectLanguage_tag:hover,
        div[id="translate"]:hover,
        div[id="translate"] .translate_selectLanguage_tag:hover {
            background: rgba(255, 255, 255, 0.25) !important;
            transform: translateY(-1px) !important;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2) !important;
        }
        
        #translate select,
        #translate .translate_selectLanguage_tag select,
        .translate_selectLanguage_tag select,
        div[id="translate"] select,
        div[id="translate"] .translate_selectLanguage_tag select {
            background: transparent !important;
            border: none !important;
            color: white !important;
            font-size: 0.9rem !important;
            font-family: inherit !important;
            cursor: pointer !important;
            outline: none !important;
            appearance: none !important;
            -webkit-appearance: none !important;
            -moz-appearance: none !important;
            width: 100% !important;
            height: 100% !important;
            padding: 8px 16px !important;
            margin: 0 !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            opacity: 1 !important;
        }
        
        #translate select option,
        #translate .translate_selectLanguage_tag select option,
        .translate_selectLanguage_tag select option,
        div[id="translate"] select option,
        div[id="translate"] .translate_selectLanguage_tag select option {
            background: white !important;
            color: #333 !important;
        }
        
        /* 移动端适配 */
        @media (max-width: 768px) {
            #translate,
            #translate .translate_selectLanguage_tag,
            .translate_selectLanguage_tag,
            div[id="translate"],
            div[id="translate"] .translate_selectLanguage_tag {
                top: 10px !important;
                right: 10px !important;
                min-width: 100px !important;
                height: 32px !important;
                font-size: 0.8rem !important;
            }
            
            #translate select,
            #translate .translate_selectLanguage_tag select,
            .translate_selectLanguage_tag select,
            div[id="translate"] select,
            div[id="translate"] .translate_selectLanguage_tag select {
                padding: 6px 12px !important;
                font-size: 0.8rem !important;
            }
        }
    </style>
</head>
<body>
    <div class="theme-toggle">
        <input type="checkbox" id="themeToggle" class="theme-toggle__checkbox">
        <label for="themeToggle" class="theme-toggle__btn">
            <span class="theme-toggle__feature"></span>
        </label>
    </div>
    <a href="../../index.html" class="return-home">← 返回主页</a>

    <div class="fo-container">
        <header class="fo-header">
            <h1 data-shadow="Lights Out - 立方体版">Lights Out - 立方体版</h1>
            <p class="fo-sub">3D立方体点灯游戏，每个灯泡有4个邻居（无边界）</p>
        </header>

        <section class="fo-panel">
            <div class="fo-left">
                <div class="fo-controls">
                    <div class="fo-row">
                        <label>关卡
                            <select id="levelSelect"></select>
                        </label>
                        <button id="prevLevel" class="fo-btn">上一关</button>
                        <button id="nextLevel" class="fo-btn">下一关</button>
                    </div>
                    <div class="fo-row">
                        <label>尺寸 <input type="number" id="sizeInput" min="2" max="8" value="2" disabled></label>
                    </div>
                    <div class="fo-row">
                        <button id="reset" class="fo-btn">重开本关</button>
                        <button id="undo" class="fo-btn" disabled>撤销</button>
                        <button id="hint" class="fo-btn">提示</button>
                        <button id="resetView" class="fo-btn">重置视角</button>
                    </div>
                    <div class="fo-row">
                        <button id="customize" class="fo-btn">自定义</button>
                        <button id="customDone" class="fo-btn fo-primary is-hidden">完成</button>
                        <a href="variant.html" class="fo-btn" id="variantBtn">返回中心</a>
                    </div>
                    <div class="fo-stats">
                        <span>步数：<b id="moveCount">0</b></span>
                        <span>目标：全亮</span>
                        <span id="statusText"></span>
                    </div>
                </div>

                <div class="fo-help">
                    <details open>
                        <summary>如何游玩 / 规则说明</summary>
                        <ul>
                            <li>立方体有6个面，每个面是 n x n 的格子</li>
                            <li>点击一个格子会翻转自身与4个邻居（无边界）</li>
                            <li>邻居包括：同面上下左右 + 跨面相邻格子</li>
                            <li>目标是将立方体中所有灯全部点亮</li>
                            <li>拖拽立方体可旋转视角</li>
                            <li>可自定义立方体尺寸与初始状态</li>
                        </ul>
                    </details>
                </div>
            </div>

            <div class="fo-board-wrap">
                <div class="cube-container">
                    <div id="cube" class="cube">
                        <div class="cube-face front" data-face="2">
                            <div class="face-label">前面</div>
                        </div>
                        <div class="cube-face back" data-face="4">
                            <div class="face-label">后面</div>
                        </div>
                        <div class="cube-face right" data-face="3">
                            <div class="face-label">右面</div>
                        </div>
                        <div class="cube-face left" data-face="1">
                            <div class="face-label">左面</div>
                        </div>
                        <div class="cube-face top" data-face="0">
                            <div class="face-label">上面</div>
                        </div>
                        <div class="cube-face bottom" data-face="5">
                            <div class="face-label">下面</div>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </div>

    <script src="assets/js/solve-cube.js"></script>
    <script>
    (function(){
        const cubeEl = document.getElementById('cube');
        const levelSelect = document.getElementById('levelSelect');
        const prevLevelBtn = document.getElementById('prevLevel');
        const nextLevelBtn = document.getElementById('nextLevel');
        const sizeInput = document.getElementById('sizeInput');
        const resetBtn = document.getElementById('reset');
        const undoBtn = document.getElementById('undo');
        const customizeBtn = document.getElementById('customize');
        const customDoneBtn = document.getElementById('customDone');
        const hintBtn = document.getElementById('hint');
        const moveCountEl = document.getElementById('moveCount');
        const statusText = document.getElementById('statusText');
        const resetViewBtn = document.getElementById('resetView');

        let TOTAL_LEVELS;
        let successTimer = null;
        let isCustomizing = false;
        let hintMode = false;
        let hintSet = new Set();
        let clickedHints = new Set();
        let cubeRotation = { x: 0, y: 0 };
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let dragThreshold = 5; // 拖拽阈值，超过此像素距离才认为是拖拽
        let hasMoved = false;

        // 立方体尺寸配置（2x2到8x8）
        const cubeSizes = [2, 3, 4, 5, 6, 7, 8];
        const levelConfigs = [];
        
        // 为每个尺寸创建4个关卡
        for (const size of cubeSizes) {
            // 第一个：全灭模式
            levelConfigs.push({ size, moves: 0, mode: 'allOff' });
            
            // 后面三个：随机模式，不同难度
            const area = 6 * size * size;
            for (let i = 1; i <= 3; i++) {
                const difficulty = 0.1 + (i - 1) * 0.05; // 0.1, 0.15, 0.2
                const moves = Math.max(1, Math.min(area, Math.round(area * difficulty)));
                levelConfigs.push({ size, moves, mode: 'random' });
            }
        }
        TOTAL_LEVELS = levelConfigs.length; // 7个尺寸 × 4个关卡 = 28关

        let currentLevelIndex = 0;
        let cubeSize = levelConfigs[0].size;
        let cube = createCube(cubeSize, 0); // 6个面，每个面是size×size的矩阵
        let moveCount = 0;
        let undoStack = [];
        const initialStates = Array(TOTAL_LEVELS).fill(null);

        init();

        function init(){
            for (let i = 0; i < TOTAL_LEVELS; i++) {
                const opt = document.createElement('option');
                opt.value = String(i);
                opt.textContent = `第 ${i + 1} 关`;
                levelSelect.appendChild(opt);
            }
            levelSelect.value = String(currentLevelIndex);

            // 立方体点击事件现在通过拖拽系统处理
            prevLevelBtn.addEventListener('click', () => switchLevel(currentLevelIndex - 1));
            nextLevelBtn.addEventListener('click', () => switchLevel(currentLevelIndex + 1));
            levelSelect.addEventListener('change', () => switchLevel(parseInt(levelSelect.value, 10)));
            resetBtn.addEventListener('click', () => generateLevel(currentLevelIndex));
            undoBtn.addEventListener('click', undoMove);

            if (customizeBtn) customizeBtn.addEventListener('click', enterCustomizeMode);
            if (customDoneBtn) customDoneBtn.addEventListener('click', finishCustomizeMode);
            if (hintBtn) hintBtn.addEventListener('click', toggleHint);

            if (sizeInput) sizeInput.addEventListener('input', onSizeInputChange);
            
            // 立方体拖拽旋转控制
            if (resetViewBtn) resetViewBtn.addEventListener('click', resetView);
            setupCubeDrag();

            generateLevel(0);
        }

        function createCube(size, fill = 0) {
            return Array.from({ length: 6 }, () => 
                Array.from({ length: size }, () => 
                    Array.from({ length: size }, () => fill)
                )
            );
        }

        function renderCube(){
            // 清空所有面的内容
            const faces = cubeEl.querySelectorAll('.cube-face');
            faces.forEach(face => {
                face.innerHTML = '';
                const faceLabel = document.createElement('div');
                faceLabel.className = 'face-label';
                faceLabel.textContent = getFaceName(parseInt(face.dataset.face));
                face.appendChild(faceLabel);
            });

            // 为每个面渲染格子
            for (let face = 0; face < 6; face++) {
                const faceEl = cubeEl.querySelector(`[data-face="${face}"]`);
                faceEl.style.gridTemplateColumns = `repeat(${cubeSize}, 1fr)`;
                faceEl.style.gridTemplateRows = `repeat(${cubeSize}, 1fr)`;
                
                for (let r = 0; r < cubeSize; r++) {
                    for (let c = 0; c < cubeSize; c++) {
                        const cell = document.createElement('button');
                        cell.className = 'cube-cell';
                        if (cube[face][r][c] === 1) cell.classList.add('on');
                        
                        const key = `${face},${r},${c}`;
                        if (hintMode && hintSet.has(key) && !clickedHints.has(key)) {
                            cell.classList.add('hint-highlight');
                        }
                        
                        cell.setAttribute('data-face', String(face));
                        cell.setAttribute('data-r', String(r));
                        cell.setAttribute('data-c', String(c));
                        faceEl.appendChild(cell);
                    }
                }
            }
            
            moveCountEl.textContent = String(moveCount);
            undoBtn.disabled = undoStack.length === 0;
            // 只在非提示模式下清空状态文本
            if (!hintMode) {
                statusText.textContent = '';
            }
        }

        function getFaceName(faceIndex) {
            const names = ['上面', '左面', '前面', '右面', '后面', '下面'];
            return names[faceIndex] || '未知';
        }

        function onCubeClick(e){
            const target = e.target;
            if(!(target instanceof HTMLElement)) return;
            if(!target.classList.contains('cube-cell')) return;
            
            const face = parseInt(target.getAttribute('data-face'), 10);
            const r = parseInt(target.getAttribute('data-r'), 10);
            const c = parseInt(target.getAttribute('data-c'), 10);
            
            if (isCustomizing){
                cube[face][r][c] = cube[face][r][c] ^ 1;
                renderCube();
                return;
            }
            
            applyCubeFlip(face, r, c, true);
            if (hintMode) {
                const key = `${face},${r},${c}`;
                clickedHints.add(key);
                renderCube();
            }
        }

        function applyCubeFlip(face, r, c, recordHistory){
            const snapshot = deepCloneCube(cube);
            
            // 获取所有需要翻转的格子（自身+4个邻居）
            const neighbors = getCubeNeighbors(face, r, c);
            
            for (const [f, row, col] of neighbors) {
                cube[f][row][col] = cube[f][row][col] ^ 1;
            }
            
            moveCount++;
            if (recordHistory) undoStack.push(snapshot);
            renderCube();
            if (isAllOn()) showSuccessModal();
        }

        function getCubeNeighbors(face, r, c) {
            const neighbors = [[face, r, c]]; // 自身
            
            // 面内邻居（上下左右）
            if (r > 0) neighbors.push([face, r - 1, c]);
            if (r < cubeSize - 1) neighbors.push([face, r + 1, c]);
            if (c > 0) neighbors.push([face, r, c - 1]);
            if (c < cubeSize - 1) neighbors.push([face, r, c + 1]);
            
            // 跨面邻居（立方体相邻面）
            // 根据solve-cube.js中的邻居逻辑
            if (face === 0) { // 上面
                if (r === 0) neighbors.push([4, 0, cubeSize - 1 - c]); // 后面
                if (r === cubeSize - 1) neighbors.push([2, 0, c]); // 前面
                if (c === 0) neighbors.push([1, 0, r]); // 左面
                if (c === cubeSize - 1) neighbors.push([3, 0, cubeSize - 1 - r]); // 右面
            } else if (face === 5) { // 下面
                if (r === 0) neighbors.push([2, cubeSize - 1, c]); // 前面
                if (r === cubeSize - 1) neighbors.push([4, cubeSize - 1, cubeSize - 1 - c]); // 后面
                if (c === 0) neighbors.push([1, cubeSize - 1, cubeSize - 1 - r]); // 左面
                if (c === cubeSize - 1) neighbors.push([3, cubeSize - 1, r]); // 右面
            } else if (face === 2) { // 前面
                if (r === 0) neighbors.push([0, cubeSize - 1, c]); // 上面
                if (r === cubeSize - 1) neighbors.push([5, 0, c]); // 下面
                if (c === 0) neighbors.push([1, r, cubeSize - 1]); // 左面
                if (c === cubeSize - 1) neighbors.push([3, r, 0]); // 右面
            } else if (face === 4) { // 后面
                if (r === 0) neighbors.push([0, 0, cubeSize - 1 - c]); // 上面
                if (r === cubeSize - 1) neighbors.push([5, cubeSize - 1, cubeSize - 1 - c]); // 下面
                if (c === 0) neighbors.push([3, r, cubeSize - 1]); // 右面
                if (c === cubeSize - 1) neighbors.push([1, r, 0]); // 左面
            } else if (face === 1) { // 左面
                if (r === 0) neighbors.push([0, c, 0]); // 上面
                if (r === cubeSize - 1) neighbors.push([5, cubeSize - 1 - c, 0]); // 下面
                if (c === 0) neighbors.push([4, r, cubeSize - 1]); // 后面
                if (c === cubeSize - 1) neighbors.push([2, r, 0]); // 前面
            } else if (face === 3) { // 右面
                if (r === 0) neighbors.push([0, cubeSize - 1 - c, cubeSize - 1]); // 上面
                if (r === cubeSize - 1) neighbors.push([5, c, cubeSize - 1]); // 下面
                if (c === 0) neighbors.push([2, r, cubeSize - 1]); // 前面
                if (c === cubeSize - 1) neighbors.push([4, r, 0]); // 后面
            }
            
            return neighbors;
        }

        function isAllOn(){
            for (let face = 0; face < 6; face++) {
                for (let r = 0; r < cubeSize; r++) {
                    for (let c = 0; c < cubeSize; c++) {
                        if (cube[face][r][c] !== 1) return false;
                    }
                }
            }
            return true;
        }

        function deepCloneCube(cube) {
            return cube.map(face => face.map(row => row.slice()));
        }

        function undoMove(){
            if (undoStack.length === 0) return;
            const prev = undoStack.pop();
            cube = prev;
            moveCount = Math.max(0, moveCount-1);
            renderCube();
        }

        function switchLevel(nextIndex){
            cancelSuccessTimer();
            if (isCustomizing) return;
            if (nextIndex < 0) nextIndex = 0;
            if (nextIndex >= TOTAL_LEVELS) nextIndex = TOTAL_LEVELS - 1;
            currentLevelIndex = nextIndex;
            levelSelect.value = String(currentLevelIndex);
            generateLevel(currentLevelIndex);
        }

        function generateLevel(levelIndex){
            cancelSuccessTimer();
            if (isCustomizing) return;
            exitHintMode();
            const config = levelConfigs[levelIndex];
            const newCubeSize = clamp(config.size, 2, 8);
            
            // 检查是否需要重新生成立方体
            if (initialStates[levelIndex] && initialStates[levelIndex][0].length === newCubeSize) {
                // 使用保存的状态
                cube = deepCloneCube(initialStates[levelIndex]);
                cubeSize = newCubeSize;
            } else {
                // 重新生成立方体
                cubeSize = newCubeSize;
                if (config.mode === 'allOff') {
                    cube = createCube(cubeSize, 0);
                } else {
                    const result = generateRandomInitialCube(cubeSize, config.moves);
                    cube = result.cube;
                }
                initialStates[levelIndex] = deepCloneCube(cube);
            }
            
            if (sizeInput) sizeInput.value = String(cubeSize);
            moveCount = 0;
            undoStack = [];
            renderCube();
        }

        function enterCustomizeMode(){
            if (isCustomizing) return;
            isCustomizing = true;
            if (sizeInput) { sizeInput.disabled = false; sizeInput.max = '8'; }
            if (customDoneBtn) customDoneBtn.classList.remove('is-hidden');
            moveCount = 0; undoStack = [];
            renderCube();
        }
        function finishCustomizeMode(){
            if (!isCustomizing) return;
            isCustomizing = false;
            initialStates[currentLevelIndex] = deepCloneCube(cube);
            if (sizeInput) sizeInput.disabled = true;
            if (customDoneBtn) customDoneBtn.classList.add('is-hidden');
            levelConfigs[currentLevelIndex].size = clamp(cubeSize, 2, 8);
            renderCube();
        }

        function onSizeInputChange(){
            if (!isCustomizing) return;
            const sizeVal = clamp(parseInt(sizeInput.value||'0',10)||0, 2, 8);
            if (sizeVal !== cubeSize){
                cubeSize = sizeVal;
                cube = createCube(cubeSize, 0);
                moveCount = 0; undoStack = [];
                renderCube();
            }
        }

        function toggleHint(){
            if (isCustomizing) return;
            if (hintMode) { exitHintMode(); } else { enterHintMode(); }
        }
        function enterHintMode(){
            try {
                // 将游戏状态转换为求解器期望的格式：灯亮=0，灯灭=1
                const solverInput = cube.map(face => 
                    face.map(row => row.map(cell => cell === 1 ? 0 : 1))
                );
                const solver = new LightsOutCubeSolver(solverInput);
                const [minFlips, solution] = solver.solve();
                
                if (!solver.hasSolution) {
                    statusText.textContent = '此初始状态无解';
                    return;
                }
                
                // 将解决方案转换为提示集合
                hintSet = new Set();
                for (let face = 0; face < 6; face++) {
                    for (let r = 0; r < cubeSize; r++) {
                        for (let c = 0; c < cubeSize; c++) {
                            if (solution[face][r][c] === 1) {
                                hintSet.add(`${face},${r},${c}`);
                            }
                        }
                    }
                }
                
                clickedHints.clear();
                hintMode = true;
                if (hintBtn) hintBtn.textContent = '隐藏提示';
                renderCube();
                statusText.textContent = `最少需要 ${minFlips} 步`;
            } catch (err) {
                statusText.textContent = '求解失败: ' + err.message;
            }
        }
        function exitHintMode(){
            hintMode = false;
            hintSet = new Set();
            clickedHints.clear();
            if (hintBtn) hintBtn.textContent = '提示';
            statusText.textContent = '';
            renderCube();
        }

        function generateRandomInitialCube(size, moves){
            const cube = createCube(size, 1); // 全亮开始
            const used = new Set();
            let steps = Math.max(1, Math.min(6 * size * size, moves|0));
            
            while (steps-- > 0){
                let face, r, c, key, guard=0;
                do {
                    face = Math.floor(Math.random() * 6);
                    r = Math.floor(Math.random() * size);
                    c = Math.floor(Math.random() * size);
                    key = `${face}:${r}:${c}`; guard++;
                    if (guard > 8) break;
                } while (used.has(key));
                used.add(key);
                
                // 应用翻转
                const neighbors = getCubeNeighbors(face, r, c);
                for (const [f, row, col] of neighbors) {
                    cube[f][row][col] = cube[f][row][col] ^ 1;
                }
            }
            
            // 保证不是全亮
            let allOn = true;
            outer: for (let f = 0; f < 6; f++) {
                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        if (cube[f][i][j] !== 1) { allOn = false; break outer; }
                    }
                }
            }
            if (allOn) {
                const neighbors = getCubeNeighbors(0, 0, 0);
                for (const [f, row, col] of neighbors) {
                    cube[f][row][col] = cube[f][row][col] ^ 1;
                }
            }
            return { cube: cube };
        }

        function setupCubeDrag() {
            // 为立方体和所有格子添加事件监听器
            cubeEl.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            
            // 触摸设备支持
            cubeEl.addEventListener('touchstart', onTouchStart, { passive: false });
            document.addEventListener('touchmove', onTouchMove, { passive: false });
            document.addEventListener('touchend', onTouchEnd);
        }

        function onMouseDown(e) {
            // 记录初始位置和状态
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            hasMoved = false;
            isDragging = false;
            
            // 如果是格子，需要特殊处理
            if (e.target.classList.contains('cube-cell')) {
                // 为格子点击设置延迟，等待判断是否为拖拽
                setTimeout(() => {
                    if (!hasMoved && !isDragging) {
                        // 如果没有移动，执行格子点击
                        onCubeClick(e);
                    }
                }, 100); // 增加延迟时间，确保拖拽判断完成
            }
            
            e.preventDefault();
        }

        function onMouseMove(e) {
            // 只有在鼠标按下时才检测移动
            if (lastMouseX === 0 && lastMouseY === 0) return;
            
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            // 如果移动距离超过阈值，开始拖拽
            if (distance > dragThreshold && !isDragging) {
                isDragging = true;
                hasMoved = true;
            }
            
            if (isDragging) {
                // 根据鼠标移动更新旋转角度
                cubeRotation.y += deltaX * 0.5; // 水平移动控制Y轴旋转
                cubeRotation.x -= deltaY * 0.5; // 垂直移动控制X轴旋转
                
                // 限制X轴旋转范围，避免过度旋转
                cubeRotation.x = Math.max(-90, Math.min(90, cubeRotation.x));
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                
                updateCubeTransform();
            }
        }

        function onMouseUp(e) {
            isDragging = false;
            hasMoved = false;
            lastMouseX = 0;
            lastMouseY = 0;
        }

        function onTouchStart(e) {
            const touch = e.touches[0];
            lastMouseX = touch.clientX;
            lastMouseY = touch.clientY;
            hasMoved = false;
            isDragging = false;
            
            // 如果是格子，需要特殊处理
            if (e.target.classList.contains('cube-cell')) {
                // 为格子点击设置延迟，等待判断是否为拖拽
                setTimeout(() => {
                    if (!hasMoved && !isDragging) {
                        // 如果没有移动，执行格子点击
                        onCubeClick(e);
                    }
                }, 100); // 增加延迟时间，确保拖拽判断完成
            }
            
            e.preventDefault();
        }

        function onTouchMove(e) {
            // 只有在触摸开始时才检测移动
            if (lastMouseX === 0 && lastMouseY === 0) return;
            
            const touch = e.touches[0];
            const deltaX = touch.clientX - lastMouseX;
            const deltaY = touch.clientY - lastMouseY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            // 如果移动距离超过阈值，开始拖拽
            if (distance > dragThreshold && !isDragging) {
                isDragging = true;
                hasMoved = true;
            }
            
            if (isDragging) {
                cubeRotation.y += deltaX * 0.5;
                cubeRotation.x -= deltaY * 0.5;
                cubeRotation.x = Math.max(-90, Math.min(90, cubeRotation.x));
                
                lastMouseX = touch.clientX;
                lastMouseY = touch.clientY;
                
                updateCubeTransform();
            }
            
            e.preventDefault();
        }

        function onTouchEnd(e) {
            isDragging = false;
            hasMoved = false;
            lastMouseX = 0;
            lastMouseY = 0;
        }

        function resetView() {
            cubeRotation = { x: 0, y: 0 };
            updateCubeTransform();
        }

        function updateCubeTransform() {
            cubeEl.style.transform = `rotateX(${cubeRotation.x}deg) rotateY(${cubeRotation.y}deg)`;
        }

        function showSuccessModal(){
            if (successTimer){ clearTimeout(successTimer); successTimer=null; }
            const modal = document.createElement('div');
            modal.className = 'success-modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <h3>立方体点亮成功！</h3>
                    <p>5 秒后自动进入下一关…</p>
                    <div class="modal-buttons">
                        <button class="btn btn-primary" id="nextNow">立即下一关</button>
                        <button class="btn btn-secondary" id="closeModal">关闭</button>
                    </div>
                </div>`;
            document.body.appendChild(modal);
            const cleanup = () => { if (modal && modal.parentNode) modal.parentNode.removeChild(modal); };
            modal.addEventListener('click', (e)=>{ if (e.target === modal) cleanup(); });
            modal.querySelector('#closeModal').addEventListener('click', cleanup);
            modal.querySelector('#nextNow').addEventListener('click', ()=>{ cleanup(); switchLevel(currentLevelIndex+1); });
            successTimer = setTimeout(()=>{ cleanup(); switchLevel(currentLevelIndex+1); }, 5000);
        }

        function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
        function cancelSuccessTimer(){ if (successTimer){ clearTimeout(successTimer); successTimer=null; } const m=document.querySelector('.success-modal'); if (m&&m.parentNode) m.parentNode.removeChild(m); }
    })();
    </script>

    <!-- translate.js 多语言翻译功能 -->
    <script src="assets/js/translate.js"></script>
    <!-- 同步标题阴影（用于翻译后保持效果） -->
    <script src="assets/js/sync-title-shadow.js"></script>
    
    <!-- 页脚 -->
    <footer class="footer">
        <p>Copyright © 2024 Tooltopia. All Rights Reserved.</p>
                <p>Designed by DSTBP</p>
    </footer>

    <script src="assets/js/translate-init.js"></script>
    <script src="assets/js/theme-toggle.js"></script>
</body>
</html>

